[{"title":"drone+rancher+docker实现自动化部署踩坑","url":"/2022/06/16/drone-rancher-docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/","content":"安装docker参考docker和docker-compose安装\n参考地址：https://yq.aliyun.com/articles/110806        \thttps://docs.docker.com/compose/install/\n\n安装rancher1.x版本\n这个地方就不用docker去pull这样一步步去安装了，直接执行运行命令，docker会检测没有镜像会去拉取\n如果需要确定拉取的rancher版本，则需要手动去一步步拉取镜像\n\nsudo docker run -d -v /var/lib/mysql:/var/lib/mysql --restart=unless-stopped -p 8236:8080 rancher/server\n\n如果没有问题会执行成功，然后访问 ip:8236\n\n\n先配置 系统管理—&gt;访问控制 根据流程设置管理员用户和其他配置\n\n\n\n\n基础框架–&gt;添加主机根据提示添加主机\n\n\n基础架构&gt;镜像库添加私有镜像库\n\n\n安装Gitea使用docker-compose运行\nsudo docker-compose -f gitea-docker-compose.yml  up -d\n\ngitea-docker-compose.yml文件内容：\nversion: &#x27;2&#x27;services:  gitea:    image: gitea/gitea:latest    container_name: gitea    ports:    - &quot;10022:22&quot;    - &quot;10080:3000&quot;    volumes:    - /var/lib/gitea:/data    restart: always\n\n启动后，访问ip:10080进入安装界面进行配置。\n安装drone在Gitea新建OAuth Application,参考官方文档。\n\n\n注意！ 将生成的客户端ID和客户端密钥保存。\ndocker-compose.yml文件内容:\nversion: &#x27;2&#x27;services:  drone-server:    image: drone/drone:1.2.1    container_name: drone-server    networks:      - dronenet        # 让drone-server和drone-agent处于一个网络中，方便进行RPC通信    ports:      - &#x27;8099:80&#x27;      # Web管理面板的入口 PROTO=http  时使用该端口      - &#x27;8999:443&#x27;     # Web管理面板的入口 PROTO=https 时使用该端口      - &#x27;9000:9000&#x27;    # RPC服务端口    volumes:      - /var/run/docker.sock:/var/run/docker.sock   # docker.sock [1]      - /var/lib/drone/:/var/lib/drone             # drone数据存放路径    environment:      - DRONE_AGENTS_ENABLED=false                   # 使用Runner      #- DRONE_GITLAB_SERVER=$&#123;DRONE_GITLAB_SERVER&#125;      #- DRONE_GITLAB_CLIENT_ID=$&#123;DRONE_GITLAB_CLIENT_ID&#125;      #- DRONE_GITLAB_CLIENT_SECRET=$&#123;DRONE_GITLAB_CLIENT_SECRET&#125;      #- DRONE_GITHUB_SERVER=$&#123;DRONE_GITHUB_SERVER&#125;     # - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125;     # - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125;      - DRONE_GITEA_SERVER=$&#123;DRONE_GITEA_SERVER&#125;                   # github的地址      - DRONE_GITEA_CLIENT_ID=$&#123;DRONE_GITEA_CLIENT_ID&#125;          # gitea获得的ClientID      - DRONE_GITEA_CLIENT_SECRET=$&#123;DRONE_GITEA_CLIENT_SECRET&#125;  # gitea获得的ClientSecret      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET&#125;                      # RPC秘钥     [2]      - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST&#125;                    # RPC域名(在一个实例上可以不用)      - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO&#125;                  # git webhook使用的协议(我建议http)      - DRONE_OPEN=true                                           # 开发drone      - DRONE_DATABASE_DATASOURCE=/var/lib/drone/drone.sqlite     # 数据库文件      - DRONE_DATABASE_DRIVER=sqlite3                             # 数据库驱动，我这里选的sqlite      #- DRONE_DATABASE_DRIVER=mysql      - DRONE_DEBUG=true                                          # 调试相关，部署的时候建议先打开      - DRONE_LOGS_DEBUG=true                                     # 调试相关，部署的时候建议先打开      - DRONE_LOGS_TRACE=true                                     # 调试相关，部署的时候建议先打开      - DRONE_USER_CREATE=username:***,admin:true           # 初始管理员用户 gitea用户名      - TZ=Asia/Shanghai                                          # 时区    restart: always  drone-agent:    image: drone/agent:1.2.1    container_name: drone-agent    networks:      - dronenet     # 让drone-server和drone-agent处于一个网络中，方便进行RPC通信    depends_on:      - drone-server    volumes:      - /var/run/docker.sock:/var/run/docker.sock # docker.sock [1]    environment:      - DRONE_RPC_SERVER=http://drone-server  # RPC服务地址      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET&#125;  # RPC秘钥        - DRONE_RPC_PROTO=$&#123;DRONE_RPC_PROTO&#125;    # RPC协议(http || https)      - DRONE_RUNNER_CAPACITY=2               # 最大并发执行的 pipeline 数      - DRONE_DEBUG=true                      # 调试相关，部署的时候建议先打开      - DRONE_LOGS_TRACE=true                 # 调试相关，部署的时候建议先打开      - TZ=Asia/Shanghai    restart: alwaysnetworks:  dronenet:                                     # 让drone-server和drone-agent处于一个网络中，方便进行RPC通信\n\n上述drone.yml中有配置从gitea获取的id和keys需要配置\n\n1、 因为插件本身也是一个容器，要在容器中(docker-server、drone-runnere)中运行容器。将docker.sock挂载到容器中，可以让容器通过docker unix socket API得到管理容器的能力。\n2、 openssl rand -hex 16 这个命令随机生成秘钥\n\n3、新建.env文件并编辑如下\n#DRONE_GITHUB_CLIENT_ID=****#DRONE_GITHUB_CLIENT_SECRET=****DRONE_GITEA_SERVER=http://git****comDRONE_GITEA_CLIENT_ID=****DRONE_GITEA_CLIENT_SECRET=****#DRONE_GITLAB_SERVER=http://git.****.com#DRONE_GITLAB_CLIENT_ID=****#DRONE_GITLAB_CLIENT_SECRET=****DRONE_RPC_SECRET=*****DRONE_SERVER_HOST=drone.****.comDRONE_SERVER_PROTO=httpsDRONE_RPC_SERVER=****:9000DRONE_RPC_PROTO=http\n\n将drone的docker-compose.yml和.env放在同一目录，然后运行以下命令：\nsudo docker-compose up -d\n\n文档参考地址：\nhttps://juejin.im/post/5d97489ee51d457824771d47https://docs.drone.io/server/provider/gitea/\n\n总结总体来说需要配置安装并让几个组件协同运作，之前配置rancher后管理的容器有存在获取不到的情况，暂时没找到如何解决的办法，查找官方手册后发现有可能是版本的问题，但没有尝试修改版本。drone的文档看起来比较费劲，有些文档写的地方不好找，有关于drone插件的文档如下：\nhttps://docs.drone.io/plugins/popular/docker/\n\n自动部署涉及到编写DockerFile，下面出个例子\n\n*** 为需要自己配置的内容\n\nFROM ***ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \\    JHIPSTER_SLEEP=0 \\    JAVA_OPTS=&quot;&quot;#设置中科大镜像，并且设置北京时间RUN \\  echo -e &quot;https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/main\\nhttps://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/community\\nhttps://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/releases&quot; &gt; /etc/apk/repositories &amp;&amp; \\  apk add --no-cache tzdata ttf-dejavu fontconfig tini &amp;&amp; \\  cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \\  echo &quot;Asia/Shanghai&quot; &gt;  /etc/timezone &amp;&amp; \\  rm -rf /var/cache/apk/*# Add a jhipster user to run our application so that it doesn&#x27;t need to run as rootRUN adduser -D -s /bin/sh ***WORKDIR /home/***ADD /src/main/resources/kdwebapi.properties kdwebapi.propertiesADD /src/main/docker/entrypoint.sh entrypoint.shRUN chmod 755 entrypoint.sh &amp;&amp; chown ***:*** entrypoint.shCOPY /src/main/resources/ttc/msyh.ttc /usr/share/fonts/ttf-dejavu/msyh.ttcRUN chown root:root /usr/share/fonts/ttf-dejavu/msyh.ttcUSER ***ENTRYPOINT [&quot;/sbin/tini&quot;,&quot;--&quot;,&quot;./entrypoint.sh&quot;]EXPOSE 8083ADD /target/*.jar app.jarADD /src/main/resources/sdk/arthas-boot.jar arthas-boot.jar\n\n\n附件：DockerFile指令表\n\n\n最后​    内容还有待补充\n更新​    不知道为什么图片莫名其妙挂了。。。\n参考了下大佬的文档：https://blog.csdn.net/z952957407/article/details/111642548\n安装插件hexo-asset-img：\nnpm install hexo-asset-img --save\n\n然后重新编译一下\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n","tags":["CI/CD"]},{"title":"学习vue基础","url":"/2022/07/10/%E5%AD%A6%E4%B9%A0vue%E5%9F%BA%E7%A1%80/","content":"ht绑定元素\n\nel: &#39;#vue&#39; : 绑定元素ID\ndata:&#123;message:&#39;Hello Vue!&#39;&#125; :数据对象中有一个名为message的值，并设置初始值为helloWorld\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--view层，模板--&gt;&lt;div id=&quot;app&quot;&gt;    &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;!--1.导入Vue.js--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        /*Model：数据*/        data:&#123;            message:&quot;hello,vue!&quot;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nv-bind绑定事件\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;comp v-for = &quot;item in items&quot; v-bind:args = &quot;item&quot;&gt;&lt;/comp&gt;    &lt;p v-bind:title=&quot;message&quot;/&gt;    鼠标悬停几秒钟查看此处动态绑定的提示信息！&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    Vue.component(&quot;comp&quot;,&#123;        props: [&#x27;args&#x27;],        template: &#x27;&lt;li&gt;&#123;&#123;args&#125;&#125;&lt;/li&gt;&#x27;    &#125;);    var vum = new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            items: [&quot;ios,app&quot;],            message: &#x27;页面加载于 &#x27; + new Date().toLocaleString()        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nv-if、v-else\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--view层，模板--&gt;&lt;div id=&quot;app&quot;&gt;    &lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;    &lt;h1 v-else&gt;No&lt;/h1&gt;   &lt;/div&gt;&lt;!--1.导入Vue.js--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        /*Model：数据*/        data:&#123;            type: true,            ok : true        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nv-for\nitems是数组，item是数组元素迭代的别名\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--view层，模板--&gt;&lt;div id=&quot;app&quot;&gt;    &lt;li v-for=&quot;(item,index) in items&quot;&gt;        &#123;&#123;item.message&#125;&#125;---&#123;&#123;index&#125;&#125;    &lt;/li&gt;&lt;/div&gt;&lt;!--1.导入Vue.js--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        /*Model：数据*/        data:&#123;            items:[                &#123;message:&#x27;狂神说Java&#x27;&#125;,                &#123;message:&#x27;狂神说前端&#x27;&#125;,                &#123;message:&#x27;狂神说运维&#x27;&#125;            ]        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nv-on\nv-on监听事件 事件有Vue的事件、和前端页面本身的一些事件!我们这里的click是vue的事件， 可以绑定到Vue中的methods中的方法事件!\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;button v-on:click=&quot;sayHi&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&#x27;Hello World&#x27;        &#125;,        methods:&#123;            sayHi:function(event)&#123;                //&#x27;this&#x27;在方法里面指向当前Vue实例                alert(this.message);            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n计算属性\n计算属性的重点突出在属性两个字上(属性是名词)，首先它是个属性其次这个属性有计算的能力(计算是动词)，这里的计算就是个函数：简单点说，它就是一个能够将计算结果缓存起来的属性(将行为转化成了静态的属性)，仅此而已；可以想象为缓存!\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--view层，模板--&gt;&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;currentTime1:&#123;&#123;currentTime1()&#125;&#125;&lt;/p&gt;    &lt;p&gt;currentTime2:&#123;&#123;currentTime2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!--1.导入Vue.js--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;          message:&quot;pan&quot;        &#125;,        methods:&#123;            currentTime1:function()&#123;                return Date.now();//返回一个时间戳            &#125;        &#125;,        computed:&#123;            currentTime2:function()&#123;//计算属性：methods，computed方法名不能重名，重名之后，只会调用methods的方法                this.message;                return Date.now();//返回一个时间戳            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注意：methods和computed里的东西不能重名说明：\nmethods：定义方法， 调用方法使用currentTime1()， 需要带括号\ncomputed：定义计算属性， 调用属性使用currentTime2， 不需要带括号：this.message是为了能够让currentTime2观察到数据变化而变化\n如何在方法中的值发生了变化，则缓存就会刷新!可以在控制台使用vm.message=”q in jiang”， 改变下数据的值，再次测试观察效果!\n结论  调用方法时，每次都需要讲行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢?此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这点，计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销\n"}]